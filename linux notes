# Understanding the Folder Structure
Explanation of System Directories
Symbolic Links (Less Significant)
Directory	Description
/sbin -> /usr/sbin	System binaries for administrative commands (linked to /usr/sbin).
/bin -> /usr/bin	Essential user binaries (linked to /usr/bin).
/lib -> /usr/lib	Shared libraries and kernel modules (linked to /usr/lib).
Important System Directories
Directory	Description
/boot	Stores files needed for booting the system (not relevant in containers).
/usr	Contains most user-installed applications and libraries.
/var	Stores logs, caches, and temporary files that change frequently.
/etc	Stores system configuration files.
User & Application-Specific Directories
Directory	Description
/home	Default location for user home directories.
/opt	Used for installing optional third-party software.
/srv	Holds data for services like web servers (rarely used in containers).
/root	Home directory for the root user.
Temporary & Volatile Directories
Directory	Description
/tmp	Temporary files (cleared on reboot).
/run	Holds runtime data for processes.
/proc	Virtual filesystem for process and system information.
/sys	Virtual filesystem for hardware and kernel information.
/dev	Contains device files (e.g., /dev/null, /dev/sda).
Mount Points
Directory	Description
/mnt	Temporary mount point for external filesystems.
/media	Mount point for removable media (USB, CDs).
/data	Likely your mounted volume from Windows (C:/ubuntu-data).

# User Management in Linux
Introduction to User Management in Linux
Linux is a multi-user operating system, meaning multiple users can operate on a system simultaneously. Proper user management ensures security, controlled access, and system integrity.

Key files involved in user management:

/etc/passwd – Stores user account details.
/etc/shadow – Stores encrypted user passwords.
/etc/group – Stores group information.
/etc/gshadow – Stores secure group details.
Creating Users in Linux
To create a new user in Linux, use:

useradd Command (For most Linux distributions)
useradd username
This creates a user without a home directory.

To create a user with a home directory:

useradd -m username
To specify a shell:

useradd -s /bin/bash username
adduser Command (For Debian-based systems)
adduser username
This is an interactive command that asks for a password and additional details.

Managing User Passwords
To set or change a user’s password:

passwd username
Enforcing Password Policies
Password expiration: Set password expiry days
chage -M 90 username
Lock a user account
passwd -l username
Unlock a user account
passwd -u username
Modifying Users
Modify an existing user with usermod:

Change the username:
usermod -l new_username old_username
Change the home directory:
usermod -d /new/home/directory -m username
Change the default shell:
usermod -s /bin/zsh username
Deleting Users
To remove a user but keep their home directory:

userdel username
To remove a user and their home directory:

userdel -r username
Working with Groups
Creating Groups
groupadd groupname
Adding Users to Groups
usermod -aG groupname username
Viewing Group Memberships
groups username
Changing Primary Group
usermod -g new_primary_group username
Sudo Access and Privilege Escalation
Adding a User to Sudo Group
On Debian-based systems:

usermod -aG sudo username
On RHEL-based systems:

usermod -aG wheel username
Granting Specific Commands with Sudo
Edit the sudoers file:

visudo
Then add:

username ALL=(ALL) NOPASSWD: /path/to/command

# File management in Linux
File and Directory Management
ls – Lists files and directories in the current location.
cd /path/to/directory – Changes the working directory.
pwd – Prints the current working directory.
mkdir new_folder – Creates a new directory.
rmdir empty_folder – Removes an empty directory.
rm file.txt – Deletes a file.
rm -r folder – Deletes a folder and its contents.
cp file1.txt file2.txt – Copies a file.
cp -r dir1 dir2 – Copies a directory recursively.
mv old_name new_name – Moves or renames a file or directory.
File Viewing and Editing
cat file.txt – Displays file content.
tac file.txt – Displays file content in reverse order.
less file.txt – Opens a file for viewing with scrolling support.
more file.txt – Similar to less, but only moves forward.
head -n 10 file.txt – Displays the first 10 lines of a file.
tail -n 10 file.txt – Displays the last 10 lines of a file.
nano file.txt – Opens a simple text editor.
vi file.txt – Opens a powerful text editor.
echo 'Hello' > file.txt – Writes text to a file, overwriting existing content.
echo 'Hello' >> file.txt – Appends text to a file without overwriting.

# VI Editor Shortcuts
Modes in VI Editor
Normal Mode (default) – Used for navigation and command execution.
Insert Mode – Used for text editing (press i to enter, Esc to exit).
Command Mode – Used for saving, quitting, and searching (press : in Normal mode).
Basic Navigation
h – Move left
l – Move right
j – Move down
k – Move up
0 – Move to the beginning of the line
^ – Move to the first non-blank character of the line
$ – Move to the end of the line
w – Move to the next word
b – Move to the previous word
gg – Move to the start of the file
G – Move to the end of the file
:n – Move to line number n
Insert Mode Shortcuts
i – Insert before cursor
I – Insert at the beginning of the line
a – Append after cursor
A – Append at the end of the line
o – Open a new line below
O – Open a new line above
Esc – Exit insert mode
Editing Text
x – Delete a character
X – Delete a character before cursor
dw – Delete a word
dd – Delete a line
d$ – Delete from cursor to end of line
d0 – Delete from cursor to beginning of line
D – Delete from cursor to end of line
u – Undo last action
Ctrl + r – Redo an undone change
yy – Copy (yank) a line
yw – Copy (yank) a word
p – Paste after the cursor
P – Paste before the cursor
Search and Replace
/pattern – Search forward for a pattern
?pattern – Search backward for a pattern
n – Repeat last search forward
N – Repeat last search backward
:%s/old/new/g – Replace all occurrences of "old" with "new"
:s/old/new/g – Replace all occurrences in the current line
Working with Multiple Files
:e filename – Open a new file
:w – Save file
:wq – Save and exit
:q! – Quit without saving
:split filename – Split screen horizontally and open another file
:vsplit filename – Split screen vertically
Ctrl + w + w – Switch between split screens

#File Permissions Management in Linux
Introduction to File Permissions
Linux file permissions determine who can read, write, or execute files and directories. Each file and directory has three levels of permission:

Owner (User): The creator of the file.
Group: Users belonging to the assigned group.
Others: All other users on the system.
Permissions are represented as:

Read (r or 4) – View file contents.
Write (w or 2) – Modify file contents.
Execute (x or 1) – Run scripts or programs.
To check file permissions, use:

ls -l filename
Output example:

-rwxr--r-- 1 user group 1234 Mar 28 10:00 myfile.sh
Changing Permissions with chmod
Using Symbolic Mode
Modify permissions using symbols:

Add (+), remove (-), or set (=) permissions.
Examples:

chmod u+x filename  # Add execute for user
chmod g-w filename  # Remove write for group
chmod o=r filename  # Set read-only for others
chmod u=rwx,g=rx,o= filename  # Set full access for user, read/execute for group, and no access for others
Using Numeric (Octal) Mode
Each permission has a value:

Read (4), Write (2), Execute (1).
Examples:

chmod 755 filename  # User (rwx), Group (r-x), Others (r-x)
chmod 644 filename  # User (rw-), Group (r--), Others (r--)
chmod 700 filename  # User (rwx), No access for others
Changing Ownership with chown
Modify file owner and group:

chown newuser filename  # Change owner
chown newuser:newgroup filename  # Change owner and group
chown :newgroup filename  # Change only group
Recursively change ownership:

chown -R newuser:newgroup directory/
Changing Group Ownership with chgrp
chgrp newgroup filename  # Change group
chgrp -R newgroup directory/  # Change group recursively
Special Permissions
SetUID (s on user execute bit)
Allows users to run a file with the file owner's permissions.

chmod u+s filename
Example: /usr/bin/passwd allows users to change their passwords.

SetGID (s on group execute bit)
Files: Users run the file with the group's permissions. Directories: Files created inside inherit the group.

chmod g+s filename  # Set on file
chmod g+s directory/  # Set on directory
Sticky Bit (t on others execute bit)
Used on directories to allow only the owner to delete their files.

chmod +t directory/
Example: /tmp directory.

Default Permissions: umask
umask defines default permissions for new files and directories. Check current umask:

umask
Set a new umask:

umask 022  # Default: 755 for directories, 644 for files
Conclusion
Understanding file permissions is essential for system security and proper file management. Using chmod, chown, and chgrp, you can control access to files and directories efficiently.

#Process Management in Linux
Introduction to Process Management
A process is an instance of a running program. Linux provides multiple utilities to monitor, manage, and control processes effectively. Each process has a unique Process ID (PID) and belongs to a parent process.

Index of Commands Covered
Viewing Processes
ps aux – View all running processes
ps -u username – View processes for a specific user
ps -C processname – Show a process by name
pgrep processname – Find a process by name and return its PID
pidof processname – Find the PID of a running program
Managing Processes
kill PID – Terminate a process by PID
pkill processname – Terminate a process by name
kill -9 PID – Force kill a process
pkill -9 processname – Kill all instances of a process
kill -STOP PID – Stop a running process
kill -CONT PID – Resume a stopped process
renice -n 10 -p PID – Lower priority of a process
renice -n -5 -p PID – Increase priority of a process (requires root)
Background & Foreground Processes
command & – Run a command in the background
jobs – List background jobs
fg %jobnumber – Bring a job to the foreground
Ctrl + Z – Suspend a running process
bg %jobnumber – Resume a suspended process in the background
Monitoring System Processes
top – Interactive process viewer
htop – User-friendly process viewer (requires installation)
nice -n 10 command – Run a command with a specific priority
renice -n -5 -p PID – Change priority of an existing process
Daemon Process Management
systemctl list-units --type=service – List all system daemons
systemctl start service-name – Start a daemon/service
systemctl stop service-name – Stop a daemon/service
systemctl enable service-name – Enable a service at startup
Viewing Process Details
Using ps
Show processes for a specific user:

ps -u username
Show a process by name:

ps -C processname
Using pgrep
Find a process by name and return its PID:

pgrep processname
Using pidof
Find the PID of a running program:

pidof processname
Managing Processes
Killing Processes
To terminate a process by PID:

kill PID
To terminate using process name:

pkill processname
Force kill a process:

kill -9 PID
Kill all instances of a process:

pkill -9 processname
Stopping & Resuming Processes
Stop a running process:

kill -STOP PID
Resume a stopped process:

kill -CONT PID
Changing Process Priority
View process priorities:

top  # Look at the NI column
Change priority of a running process:

renice -n 10 -p PID  # Lower priority (positive values)
renice -n -5 -p PID  # Higher priority (negative values, root required)
Running Processes in the Background
Run a command in the background:

command &
List background jobs:

jobs
Bring a job to the foreground:

fg %jobnumber
Send a running process to the background:

Ctrl + Z  # Suspend process
bg %jobnumber  # Resume in background
Monitoring System Processes
Using top
Interactive process viewer:

Press k and enter a PID to kill a process.
Press r to renice a process.
Press q to quit.
Using htop
A user-friendly alternative to top:

htop
Allows mouse-based interaction for process management.

Using nice & renice
Run a command with a specific priority:

nice -n 10 command
Change the priority of an existing process:

renice -n -5 -p PID
Daemon Processes
Daemon processes run in the background without user intervention. List all system daemons:

systemctl list-units --type=service
Start a daemon:

systemctl start service-name
Stop a daemon:

systemctl stop service-name
Enable a service at startup:

systemctl enable service-name
Conclusion
Process management is crucial for system performance and stability. By using tools like ps, top, htop, kill, and nice, you can efficiently control and monitor Linux processes.

# Process Management in Linux
Introduction to Process Management
A process is an instance of a running program. Linux provides multiple utilities to monitor, manage, and control processes effectively. Each process has a unique Process ID (PID) and belongs to a parent process.

Index of Commands Covered
Viewing Processes
ps aux – View all running processes
ps -u username – View processes for a specific user
ps -C processname – Show a process by name
pgrep processname – Find a process by name and return its PID
pidof processname – Find the PID of a running program
Managing Processes
kill PID – Terminate a process by PID
pkill processname – Terminate a process by name
kill -9 PID – Force kill a process
pkill -9 processname – Kill all instances of a process
kill -STOP PID – Stop a running process
kill -CONT PID – Resume a stopped process
renice -n 10 -p PID – Lower priority of a process
renice -n -5 -p PID – Increase priority of a process (requires root)
Background & Foreground Processes
command & – Run a command in the background
jobs – List background jobs
fg %jobnumber – Bring a job to the foreground
Ctrl + Z – Suspend a running process
bg %jobnumber – Resume a suspended process in the background
Monitoring System Processes
top – Interactive process viewer
htop – User-friendly process viewer (requires installation)
nice -n 10 command – Run a command with a specific priority
renice -n -5 -p PID – Change priority of an existing process
Daemon Process Management
systemctl list-units --type=service – List all system daemons
systemctl start service-name – Start a daemon/service
systemctl stop service-name – Stop a daemon/service
systemctl enable service-name – Enable a service at startup
Viewing Process Details
Using ps
Show processes for a specific user:

ps -u username
Show a process by name:

ps -C processname
Using pgrep
Find a process by name and return its PID:

pgrep processname
Using pidof
Find the PID of a running program:

pidof processname
Managing Processes
Killing Processes
To terminate a process by PID:

kill PID
To terminate using process name:

pkill processname
Force kill a process:

kill -9 PID
Kill all instances of a process:

pkill -9 processname
Stopping & Resuming Processes
Stop a running process:

kill -STOP PID
Resume a stopped process:

kill -CONT PID
Changing Process Priority
View process priorities:

top  # Look at the NI column
Change priority of a running process:

renice -n 10 -p PID  # Lower priority (positive values)
renice -n -5 -p PID  # Higher priority (negative values, root required)
Running Processes in the Background
Run a command in the background:

command &
List background jobs:

jobs
Bring a job to the foreground:

fg %jobnumber
Send a running process to the background:

Ctrl + Z  # Suspend process
bg %jobnumber  # Resume in background
Monitoring System Processes
Using top
Interactive process viewer:

Press k and enter a PID to kill a process.
Press r to renice a process.
Press q to quit.
Using htop
A user-friendly alternative to top:

htop
Allows mouse-based interaction for process management.

Using nice & renice
Run a command with a specific priority:

nice -n 10 command
Change the priority of an existing process:

renice -n -5 -p PID
Daemon Processes
Daemon processes run in the background without user intervention. List all system daemons:

systemctl list-units --type=service
Start a daemon:

systemctl start service-name
Stop a daemon:

systemctl stop service-name
Enable a service at startup:

systemctl enable service-name
Conclusion
Process management is crucial for system performance and stability. By using tools like ps, top, htop, kill, and nice, you can efficiently control and monitor Linux processes.

# Linux System Monitoring
Introduction to System Monitoring
Monitoring system resources is essential to ensure optimal performance, detect issues, and troubleshoot problems in Linux. Various tools allow us to monitor CPU, memory, disk usage, network activity, and running processes.

Index of Commands Covered
CPU and Memory Monitoring
top – Real-time system monitoring
htop – Interactive process viewer (requires installation)
vmstat – Report system performance statistics
free -m – Show memory usage
Disk Monitoring
df -h – Check disk space usage
du -sh /path – Show disk usage of a specific directory
iostat – Display CPU and disk I/O statistics
Network Monitoring
ifconfig – Show network interfaces (deprecated, use ip a)
ip a – Show network interface details
netstat -tulnp – Show active connections and listening ports
ss -tulnp – Alternative to netstat for socket statistics
ping hostname – Test network connectivity
traceroute hostname – Show network path to a host
nslookup domain – Get DNS resolution details
Log Monitoring
tail -f /var/log/syslog – Live monitoring of system logs
journalctl -f – Live system logs for systemd-based distros
dmesg | tail – View kernel logs
CPU and Memory Monitoring
Using top
To view real-time CPU and memory usage:

top
Press q to quit.

Using htop
A user-friendly alternative:

htop
Use arrow keys to navigate and F9 to kill processes.

Using vmstat
To check CPU, memory, and I/O stats:

vmstat 1 5  # Update every 1 sec, show 5 updates
Checking Memory Usage
free -m
Shows free and used memory in megabytes.

Disk Monitoring
Using df
Check available disk space:

df -h
Using du
Find the size of a directory:

du -sh /var/log
Using iostat
Check disk and CPU usage:

iostat
Network Monitoring
Checking Network Interfaces
ip a  # Show IP addresses and interfaces
Viewing Open Ports and Connections
netstat -tulnp  # Show listening ports
ss -tulnp  # Alternative to netstat
Testing Connectivity
ping google.com  # Test internet connection
traceroute google.com  # Trace the path to Google
Checking DNS Resolution
nslookup example.com
Log Monitoring
Live Monitoring of System Logs
tail -f /var/log/syslog  # Follow logs in real-time
journalctl -f  # Systemd logs
Checking Kernel Logs
dmesg | tail
# Networking Commands
ping google.com – Checks connectivity to a remote server.
ifconfig – Displays network interfaces (deprecated, use ip).
ip a – Shows IP addresses of network interfaces.
netstat -tulnp – Displays open network connections.
curl https://example.com – Fetches a webpage's content.
wget https://example.com/file.zip – Downloads a file from the internet.

# Disk and Storage Management in Linux
Introduction to Disk and Storage Management
Managing disks and storage efficiently is crucial for system performance and stability. Linux provides various commands to monitor, partition, format, mount, and manage disk storage.

Index of Commands Covered
Viewing Disk Information
lsblk – Display block devices
fdisk -l – List disk partitions
blkid – Show UUIDs of devices
df -h – Check disk space usage
du -sh /path – Show size of a directory
Partition Management
fdisk /dev/sdX – Create and manage partitions
parted /dev/sdX – Alternative to fdisk for GPT disks
mkfs.ext4 /dev/sdX1 – Format a partition as ext4
mkfs.xfs /dev/sdX1 – Format a partition as XFS
Mounting and Unmounting
mount /dev/sdX1 /mnt – Mount a partition
umount /mnt – Unmount a partition
mount -o remount,rw /mnt – Remount a partition as read-write
Logical Volume Management (LVM)
pvcreate /dev/sdX – Create a physical volume
vgcreate vg_name /dev/sdX – Create a volume group
lvcreate -L 10G -n lv_name vg_name – Create a logical volume
mkfs.ext4 /dev/vg_name/lv_name – Format an LVM partition
mount /dev/vg_name/lv_name /mnt – Mount an LVM partition
Swap Management
mkswap /dev/sdX – Create a swap partition
swapon /dev/sdX – Enable swap space
swapoff /dev/sdX – Disable swap space
Viewing Disk Information
Using lsblk
List all block devices:

lsblk
Using fdisk
View partition details:

fdisk -l
Using df
Check available disk space:

df -h
Using du
Find the size of a directory:

du -sh /var/log
Partition Management
Creating a Partition with fdisk
fdisk /dev/sdX
Follow the interactive prompts to create a partition.

Formatting a Partition
Format as ext4:

mkfs.ext4 /dev/sdX1
Format as XFS:

mkfs.xfs /dev/sdX1
Mounting and Unmounting
Mount a Partition
mount /dev/sdX1 /mnt
Unmount a Partition
umount /mnt
Remount a Partition
mount -o remount,rw /mnt
LVM Management
Create a Physical Volume
pvcreate /dev/sdX
Create a Volume Group
vgcreate vg_name /dev/sdX
Create a Logical Volume
lvcreate -L 10G -n lv_name vg_name
Format and Mount the Logical Volume
mkfs.ext4 /dev/vg_name/lv_name
mount /dev/vg_name/lv_name /mnt
Swap Management
Create a Swap Partition
mkswap /dev/sdX
Enable Swap
swapon /dev/sdX
Disable Swap
swapoff /dev/sdX
